// These will be replaced with job parameters.
IMAGE_NAME = 'maidsafe/safe-client-libs-build'
IMAGE_TAG = '0.9.0'
REPO_URL = 'https://github.com/jacderida/safe_client_libs.git'

stage('build') {
    parallel real: {
        node('docker_slave-centos-7.5-x86_64') {
            git([url: REPO_URL, branch: 'docker_build'])
            clean()
            build_safe_client_libs('real')
            commit_container_artifacts('real')
        }
    },
    mock: {
        node('docker_slave-centos-7.5-x86_64') {
            git([url: REPO_URL, branch: 'docker_build'])
            clean()
            build_safe_client_libs('mock')
            commit_container_artifacts('mock')
        }
    }
}

stage('test mocked libs') {
    node('docker_slave-centos-7.5-x86_64') {
        run_mocked_tests()
    }
}

stage('packaging') {
    node('docker_slave-centos-7.5-x86_64') {
        for (app in ['safe_app', 'safe_authenticator']) {
            run_packaging(app)
        }
        move_packages_to_deploy()
    }
}

stage('deployment') {
    node('docker_slave-centos-7.5-x86_64') {
        withAWS(credentials: 'aws_jenkins_user_credentials', region: 'eu-west-2') {
            def artifacts = sh(returnStdout: true, script: 'ls -1 deploy').trim().split("\\r?\\n")
            for (artifact in artifacts) {
                s3Upload(
                    bucket: 'safe-client-libs-jenkins',
                    file: artifact,
                    workingDir: "${env.WORKSPACE}/deploy",
                    acl: 'PublicRead')
            }
        }
    }
}

def clean() {
    // The next 2 commands will fail if there are currently no containers (because it's the first build or
    // because they had been cleaned out manually), as they will pass an empty list to xargs. The reason for
    // the '|| true' at the end is to prevent the build failing in this case.
    sh($/eval "docker ps -a | grep 'safe_client_libs_*' | awk '{ print \$1 }' | xargs docker rm || true"/$)
    sh($/eval "docker images | grep -E 'build-real|build-mock' | awk '{ print \$3 }' | xargs docker rmi || true"/$)
    sh("rm -f *.zip")
    sh("rm -rf deploy")
}

def get_user_details() {
    def user_id = sh(returnStdout: true, script: 'echo $UID').trim()
    def group_id = sh(returnStdout: true, script: $/eval 'getent group $USER | awk -F : "{ print \$3 }"'/$).trim()
    return [user_id, group_id]
}

def get_committed_build_image_name(mode) {
    def tag = "build-${mode}-${env.BUILD_NUMBER}"
    return "${IMAGE_NAME}:${tag}"
}

def build_safe_client_libs(mode) {
    def user_details = get_user_details()
    def user_id = user_details[0]
    def group_id = user_details[1]
    def image_name = "${IMAGE_NAME}:${IMAGE_TAG}"
    sh("docker run --name safe_client_libs_${mode} " +
       "-v ${env.WORKSPACE}:/usr/src/crust:Z " +
       "-u ${user_id}:${group_id} " +
       "${image_name} scripts/build-${mode} /target")
}

def commit_container_artifacts(mode) {
    def container_name = "safe_client_libs_${mode}"
    def container_id = sh(returnStdout: true, script: $/eval "docker ps -a | grep -w '${container_name}' | awk '{ print \$1 }'" /$).trim()
    def image_name = get_committed_build_image_name(mode)
    sh("docker commit ${container_id} ${image_name}")
    sh("docker rm ${container_name}")
}

def run_mocked_tests() {
    def user_details = get_user_details()
    def user_id = user_details[0]
    def group_id = user_details[1]
    def image_name = get_committed_build_image_name('mock')
    sh("docker run --rm --name safe_client_libs_mock_test_run " +
       "-v ${env.WORKSPACE}:/usr/src/crust:Z " +
       "-u ${user_id}:${group_id} " +
       "${image_name} scripts/test-mock /target")
}

def run_packaging(app) {
    def user_details = get_user_details()
    def user_id = user_details[0]
    def group_id = user_details[1]
    for (mode in ['real', 'mock']) {
        def image_name = get_committed_build_image_name(mode)
        def command = "docker run --rm --name safe_${app}_${mode}_package " +
            "-v ${env.WORKSPACE}:/usr/src/crust:Z " +
            "-u ${user_id}:${group_id} " +
            "${image_name} scripts/package.rs --lib --name ${app} --commit"
        if (mode == 'mock') {
            command += " --mock"
        }
        sh(command)
    }
}

def move_packages_to_deploy() {
    sh('mkdir deploy')
    sh('mv *.zip deploy')
}
